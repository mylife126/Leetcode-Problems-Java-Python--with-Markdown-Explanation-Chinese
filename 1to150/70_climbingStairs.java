/*
假设3步，
那么要第0步和第1步，肯定只有一种走法，那就是0&1， 原地踏步或者走一步。

走到第二步，则可以要么是从第一步+1 或者从 第0步+2， 所以2种。

走到第三步，则可可以是 2 + 1 = 3 or 1 + 2 = 3, 但是呢走到步数2 已经有两种走法了，所以走到步数3则可以是  2 + 1 = 3 种

所以：
1. state function: dp[n + 1], 0 ~ n步，每一个dp[i]都是在i步的时候能有几个走法
2. init： dp[0] = 1, dp[1] = 1 走0步的走法只有0，原地踏步， 走到1步的走法只有1，那就是从0走一步
3. transfer function: dp[i] = dp[i - 1] + dp[i - 2] if i >= 2;
4. result = dp[n], 
*/


class Solution {
    public int climbStairs(int n) {
        if (n == 0){
            return 0;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 1; // 走0步只有一种走法
        dp[1] = 1; // 走1步也是一种走法
        
        for (int i = 2; i <= n; i++){
            //走i步的时候，可以从 i - 1 再走一步，所以这是一种， 但我们得累计走到 i - 1的总走法
            dp[i] = dp[i - 1];
            if (i >= 2){
                //或者，可以从 i -2的地方再走两部，这又是一种走法。 但我们得累计 走到i - 2的总走法到这一步
                dp[i] += dp[i - 2];
            }
        }
        //最后return 走到n的总走法就好了
        return dp[n];
        
    }
}